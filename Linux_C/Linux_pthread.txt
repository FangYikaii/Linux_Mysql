一、线程

编译：有thread要加-lpthread
gcc mutex.c -o mutex -lpthread

（1）线程创建
pthread_create是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。
int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);
编译连接参数：-lpthread

第一个参数为指向线程标识符的指针。
第二个参数用来设置线程属性。
第三个参数是线程运行函数的起始地址。
最后一个参数是运行函数的参数。
若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。

注意：参数运行地址函数要加*，指针

（2）线程互斥
1.初始化锁：
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  //pthread_mutex_t 结构体

锁可以用pthread_mutex_init函数动态的创建，函数原型如下：
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr)
2.加锁
 int pthread_mutex_lock(pthread_mutex_t *mutex);
当pthread_mutex_lock()返回时，该互斥锁已被锁定。线程调用该函数让互斥锁上锁，如果该互斥锁已被另一个线程锁定和拥有，则调用该线程将阻塞，直到该互斥锁变为可用为止。 对于 Solaris线程，请参见mutex_lock 语法。
在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。
3.解锁
解锁pthread_mutex_unlock()
4.释放锁
调用pthread_mutex_destory之后，可以释放锁占用的资源，但这有一个前提上锁当前是没有被锁的状态。

（3）死锁
所谓死锁： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。
一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被
死锁
死锁
其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。

死锁的发生必须具备以下四个必要条件。
1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4）环路等待条件：指在发生死锁时，必然存在一个进程――资源的环形链，即进程集合{P0，P1，P2，・・・，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。


（4）pthread_join
函数pthread_join用来等待一个线程的结束,线程间同步的操作。头文件 ： #include <pthread.h>
函数定义： int pthread_join(pthread_t thread, void **retval);
描述 ：pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。
参数 ：thread: 线程标识符，即线程ID，标识唯一线程。retval: 用户定义的指针，用来存储被等待线程的返回值。
返回值 ： 0代表成功。 失败，返回的则是错误号。

	pthread_join的应用
pthread_join使一个线程等待另一个线程结束。
代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。
所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。通过调用pthread_self()函数可以获得自身的线程号。










二、进程
（1）进程号的类型定义
pid_t

（2）fork()
在UNIX里，除了进程0(即PID=0的交换进程，Swapper Process)以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。
操作系统内核以进程标识符(Process Identifier，即PID)来识别进程。进程0是系统引导时创建的一个特殊进程，在其调用fork创建出一个子进程(即PID=1的进程1，又称init)后，进程0就转为交换进程(有时也被称为空闲进程)，而进程1(init进程)就是系统里其他所有进程的祖先。

分叉函数，一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程(child process) 这意味着父子进程间不共享这些存储空间。
UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。

返回值：如果成功则一次返回两个值，子进程返回0，父进程返回子进程ID。如果出错，返回负1。

这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。

fork出错可能有两种原因：
    1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
    2）系统内存不足，这时errno的值被设置为ENOMEM

（3）getpid() 获取当前进程id
getppid() 获取当前父进程id

（4）线程等待
waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。
头文件：#include<sys/types.h> #include<sys/wait.h>
定义函数 pid_t waitpid(pid_t pid,int * status,int options);如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码,
 
其他数值意义如下:
pid<-1 等待进程组识别码为 pid 绝对值的任何子进程。
pid=-1 等待任何子进程,相当于 wait()。
pid=0 等待进程组识别码与目前进程相同的任何子进程。
pid>0 等待任何子进程识别码为 pid 的子进程。



三、wait和waitpid函数
我们知道在unix/Linux中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程,即父进程永远无法预测子进程 到底什么时候结束。 当一个进程完成它的工作终止之后，它的父进程需要调用wait()或者waitpid()系统调用取得子进程的终止状态。
　　孤儿进程：一个父进程退出，而它的一个或多个子进程还在运行，那么那些子进程将成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。
　　僵尸进程：一个进程使用fork创建子进程，如果子进程退出，而父进程并没有调用wait或waitpid获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中。这种进程称之为僵尸进程。
重要概念：
　　 一个进程在调用exit命令结束自己生命的时候，其实它并没有真正的被销毁，而是留下一个称为僵尸进程（Zombie）的数据结构。系统调用exit的作用是使进程退出，但也仅仅限于将一个正常的进程变成一个僵尸进程，并不能将其完全销毁。 
　　 在Linux进程的状态中，僵尸进程是非常特殊的一种，它已经放弃了几乎所有的空间，没有任何可执行代码，也不能被调度，仅仅在进程的列表中保留一个位置，记载该进程的退出状态等信息供其他进程收集。除此之外，僵尸进程不再占有任何内存空间。
　　 它需要他的父进程来为他收尸，如果他的父进程没有安装SIGCHLD信息处理函数调用wait或waitpid等待子进程的结束，又没有显示忽略该信息，那么它就一直保持僵尸状态，如果这时候父进程结束了，那么init进程自动会接手这个子进程，为它收尸，它还是能被清除的。
     但是如果父进程是一个循环，不会结束，那么子进程交一直保持僵尸状态，这就是为什么系统中有时会有很多僵尸进程。
问题及危害：
　　unix提供了一种机制可以保证只要父进程想知道子进程结束时的状态信息， 就可以得到。这种机制就是: 
    在每个进程退出的时候,内核释放该进程所有的资源,包括打开的文件,占用的内存等。 但是仍然为其保留一定的信息(包括进程号the process ID,退出状态the termination status of the process,运行时间the amount of CPU time taken by the process等)。
    直到父进程通过wait / waitpid来取时才释放。 但这样就导致了问题，如果进程不调用wait / waitpid的话， 那么保留的那段信息就不会释放，其进程号就会一直被占用，但是系统所能使用的进程号是有限的，如果大量的产生僵死进程，将因为没有可用的进程号而导致系统不能产生新的进程. 此即为僵尸进程的危害，应当避免。
　　僵尸进程危害场景：
　　例如有个进程，它定期的产生一个子进程，这个子进程需要做的事情很少，做完它该做的事情之后就退出了，因此这个子进程的生命周期很短，但是，父进程只管生成新的子进程，至于子进程退出之后的事情，则一概不闻不问，这样，系统运行上一段时间之后，系统中就会存在很多的僵死进程，倘若用ps命令查看的话，就会看到很多状态为Z的进程。 
     严格地来说，僵死进程并不是问题的根源，罪魁祸首是产生出大量僵死进程的那个父进程。因此，当我们寻求如何消灭系统中大量的僵死进程时，答案就是把产生大量僵死进程的那个元凶枪毙掉（也就是通过kill发送SIGTERM或者SIGKILL信号啦）。枪毙了元凶进程之后，它产生的僵死进程就变成了孤儿进程，这些孤儿进程会被init进程接管，init进程会wait()这些孤儿进程，释放它们占用的系统进程表中的资源，这样，这些已经僵死的孤儿进程 就能瞑目而去了。
四种僵尸进程避免方式：
1.wait和waitpid函数 
2.signal安装处理函数（交给内核处理） 
3.signal忽略SIGCHLD信号（交给内核处理） 
4.fork两次

wait和waitpid：
wait系统调用在Linux函数库中的原型是：
#include <sys/types.h>  /*提供类型pid_t的定义*/
#include <sys/wait.h>
pid_t wait(int *status)
进程一旦调用了wait，就立即阻塞自己，由wait自动分析是否当前进程的某个子进程已经退出，如果让它找到了这样一个已经变成僵尸的子进程，wait就会收集这个子进程的信息，并把它彻底销毁后返回；如果没有找到这样一个子进程，wait就会一直阻塞在这里，直到有一个出现为止。（wait第一个结束的进程）
参数status用来保存被收集进程退出时的一些状态，它是一个指向int类型的指针。但如果我们对这个子进程是如何死掉的毫不在意，只想把这个僵尸进程消灭掉，（事实上绝大多数情况下，我们都会这样想），我们就可以设定这个参数为NULL，就象下面这样：pid = wait(NULL);
如果成功，wait会返回被收集的子进程的进程ID，如果调用进程没有子进程，调用就会失败，此时wait返回-1，同时errno被置为ECHILD。

waitpid系统调用在Linux函数库中的原型是：
#include <sys/types.h> /* 提供类型pid_t的定义 */
#include <sys/wait.h>
pid_t waitpid(pid_t pid,int *status,int options)
从本质上讲，系统调用waitpid和wait的作用是完全相同的，但waitpid多出了两个可由用户控制的参数pid和options，从而为我们编程提供了另一种更灵活的方式。下面我们就来详细介绍一下这两个参数：
pid：从参数的名字pid和类型pid_t中就可以看出，这里需要的是一个进程ID。但当pid取不同的值时，在这里有不同的意义。 
pid>0时，只等待进程ID等于pid的子进程，不管其它已经有多少子进程运行结束退出了，只要指定的子进程还没有结束，waitpid就会一直等下去。 
pid=-1时，等待任何一个子进程退出，没有任何限制，此时waitpid和wait的作用一模一样。 
pid=0时，等待同一个进程组中的任何子进程，如果子进程已经加入了别的进程组，waitpid不会对它做任何理睬。 
pid<-1时，等待一个指定进程组中的任何子进程，这个进程组的ID等于pid的绝对值。
options：options提供了一些额外的选项来控制waitpid，目前在Linux中只支持0（阻塞），WNOHANG（非阻塞）和WUNTRACED两个选项，这是两个常数，可以用”|”运算符把它们连接起来使用。
比如： 
ret = waitpid(-1,NULL,WNOHANG | WUNTRACED);
使用了WNOHANG参数调用waitpid，即使没有子进程退出，它也会立即返回，不会像wait那样永远等下去。 


