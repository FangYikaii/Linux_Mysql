一、线程

编译：有thread要加-lpthread
gcc mutex.c -o mutex -lpthread

（1）线程创建
pthread_create是类Unix操作系统（Unix、Linux、Mac OS X等）的创建线程的函数。
int pthread_create(pthread_t *tidp,const pthread_attr_t *attr,(void*)(*start_rtn)(void*),void *arg);
编译连接参数：-lpthread

第一个参数为指向线程标识符的指针。
第二个参数用来设置线程属性。
第三个参数是线程运行函数的起始地址。
最后一个参数是运行函数的参数。
若线程创建成功，则返回0。若线程创建失败，则返回出错编号，并且*thread中的内容是未定义的。

注意：参数运行地址函数要加*，指针

（2）线程互斥
1.初始化锁：
pthread_mutex_t mutex = PTHREAD_MUTEX_INITIALIZER;  //pthread_mutex_t 结构体

锁可以用pthread_mutex_init函数动态的创建，函数原型如下：
int pthread_mutex_init(pthread_mutex_t *mutex, const pthread_mutexattr_t * attr)
2.加锁
 int pthread_mutex_lock(pthread_mutex_t *mutex);
当pthread_mutex_lock()返回时，该互斥锁已被锁定。线程调用该函数让互斥锁上锁，如果该互斥锁已被另一个线程锁定和拥有，则调用该线程将阻塞，直到该互斥锁变为可用为止。 对于 Solaris线程，请参见mutex_lock 语法。
在成功完成之后会返回零。其他任何返回值都表示出现了错误。如果出现以下任一情况，该函数将失败并返回对应的值。
3.解锁
解锁pthread_mutex_unlock()
4.释放锁
调用pthread_mutex_destory之后，可以释放锁占用的资源，但这有一个前提上锁当前是没有被锁的状态。

（3）死锁
所谓死锁： 是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。

死锁的规范定义：集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该组进程是死锁的。
一种情形，此时执行程序中两个或多个线程发生永久堵塞（等待），每个线程都在等待被
死锁
死锁
其他线程占用并堵塞了的资源。例如，如果线程A锁住了记录1并等待记录2，而线程B锁住了记录2并等待记录1，这样两个线程就发生了死锁现象。

死锁的发生必须具备以下四个必要条件。
1）互斥条件：指进程对所分配到的资源进行排它性使用，即在一段时间内某资源只由一个进程占用。如果此时还有其它进程请求资源，则请求者只能等待，直至占有资源的进程用毕释放。
2）请求和保持条件：指进程已经保持至少一个资源，但又提出了新的资源请求，而该资源已被其它进程占有，此时请求进程阻塞，但又对自己已获得的其它资源保持不放。
3）不剥夺条件：指进程已获得的资源，在未使用完之前，不能被剥夺，只能在使用完时由自己释放。
4）环路等待条件：指在发生死锁时，必然存在一个进程――资源的环形链，即进程集合{P0，P1，P2，・・・，Pn}中的P0正在等待一个P1占用的资源；P1正在等待P2占用的资源，……，Pn正在等待已被P0占用的资源。


（4）pthread_join
函数pthread_join用来等待一个线程的结束,线程间同步的操作。头文件 ： #include <pthread.h>
函数定义： int pthread_join(pthread_t thread, void **retval);
描述 ：pthread_join()函数，以阻塞的方式等待thread指定的线程结束。当函数返回时，被等待线程的资源被收回。如果线程已经结束，那么该函数会立即返回。并且thread指定的线程必须是joinable的。
参数 ：thread: 线程标识符，即线程ID，标识唯一线程。retval: 用户定义的指针，用来存储被等待线程的返回值。
返回值 ： 0代表成功。 失败，返回的则是错误号。

	pthread_join的应用
pthread_join使一个线程等待另一个线程结束。
代码中如果没有pthread_join主线程会很快结束从而使整个进程结束，从而使创建的线程没有机会开始执行就结束了。加入pthread_join后，主线程会一直等待直到等待的线程结束自己才结束，使创建的线程有机会执行。
所有线程都有一个线程号，也就是Thread ID。其类型为pthread_t。通过调用pthread_self()函数可以获得自身的线程号。










二、进程
（1）进程号的类型定义
pid_t

（2）fork()
在UNIX里，除了进程0(即PID=0的交换进程，Swapper Process)以外的所有进程都是由其他进程使用系统调用fork创建的，这里调用fork创建新进程的进程即为父进程，而相对应的为其创建出的进程则为子进程，因而除了进程0以外的进程都只有一个父进程，但一个进程可以有多个子进程。
操作系统内核以进程标识符(Process Identifier，即PID)来识别进程。进程0是系统引导时创建的一个特殊进程，在其调用fork创建出一个子进程(即PID=1的进程1，又称init)后，进程0就转为交换进程(有时也被称为空闲进程)，而进程1(init进程)就是系统里其他所有进程的祖先。

分叉函数，一个现有进程可以调用fork函数创建一个新进程。由fork创建的新进程被称为子进程(child process)。子进程是父进程的副本，它将获得父进程数据空间、堆、栈等资源的副本。注意，子进程持有的是上述存储空间的"副本"，这意味着父子进程间不共享这些存储空间。
UNIX将复制父进程的地址空间内容给子进程，因此，子进程有了独立的地址空间。在不同的UNIX (Like)系统下，我们无法确定fork之后是子进程先运行还是父进程先运行，这依赖于系统的实现。所以在移植代码的时候我们不应该对此作出任何的假设。

返回值：如果成功则一次返回两个值，子进程返回0，父进程返回子进程ID。如果出错，返回负1。

这两个进程的变量都是独立的，存在不同的地址中，不是共用的，这点要注意。可以说，我们就是通过fpid来识别和操作父子进程的。

fork出错可能有两种原因：
    1）当前的进程数已经达到了系统规定的上限，这时errno的值被设置为EAGAIN。
    2）系统内存不足，这时errno的值被设置为ENOMEM

（3）getpid() 获取当前进程id
getppid() 获取当前父进程id

（4）线程等待
waitpid()会暂时停止目前进程的执行，直到有信号来到或子进程结束。
头文件：#include<sys/types.h> #include<sys/wait.h>
定义函数 pid_t waitpid(pid_t pid,int * status,int options);如果在调用 waitpid()时子进程已经结束,则 waitpid()会立即返回子进程结束状态值。 子进程的结束状态值会由参数 status 返回,而子进程的进程识别码也会一起返回。如果不在意结束状态值,则参数 status 可以设成 NULL。参数 pid 为欲等待的子进程识别码,
 
其他数值意义如下:
pid<-1 等待进程组识别码为 pid 绝对值的任何子进程。
pid=-1 等待任何子进程,相当于 wait()。
pid=0 等待进程组识别码与目前进程相同的任何子进程。
pid>0 等待任何子进程识别码为 pid 的子进程。

（5）pipe
管道是一种把两个进程之间的标准输入和标准输出连接起来的机制，从而提供一种让多个进程间通信的方法，当进程创建管道时，每次都需要提供两个文件描述符来操作管道。其中一个对管道进行写操作，另一个对管道进行读操作。对管道的读写与一般的IO系统函数一致，使用write()函数写入数据，使用read()读出数据。 
#include<unistd.h>
int pipe(int filedes[2]);
返回值：成功，返回0，否则返回-1。参数数组包含pipe使用的两个文件的描述符。fd[0]:读管道，fd[1]:写管道。
必须在fork()中调用pipe()，否则子进程不会继承文件描述符。两个进程不共享祖先进程，就不能使用pipe。但是可以使用命名管道。
